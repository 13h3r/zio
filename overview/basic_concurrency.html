<html><head><title>: Basic Concurrency</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="ZIO contributors" /><meta name="description" content="Type-safe, composable asynchronous and concurrent programming for Scala" /><meta name="og:image" content="/scalaz-zio/img/poster.png" /><meta name="image" property="og:image" content="/scalaz-zio/img/poster.png" /><meta name="og:title" content=": Basic Concurrency" /><meta name="title" property="og:title" content=": Basic Concurrency" /><meta name="og:site_name" content="" /><meta name="og:url" content="https://scalaz.github.io/scalaz-zio/" /><meta name="og:type" content="website" /><meta name="og:description" content="Type-safe, composable asynchronous and concurrent programming for Scala" /><link rel="icon" type="image/png" href="/scalaz-zio/img/favicon.png" /><meta name="twitter:title" content=": Basic Concurrency" /><meta name="twitter:image" content="/scalaz-zio/img/poster.png" /><meta name="twitter:description" content="Type-safe, composable asynchronous and concurrent programming for Scala" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="512x512" href="/scalaz-zio/img/favicon.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalaz-zio/highlight/styles/default.css" /><link rel="stylesheet" href="/scalaz-zio/css/style.css" /><link rel="stylesheet" href="/scalaz-zio/css/palette.css" /><link rel="stylesheet" href="/scalaz-zio/css/codemirror.css" /><link rel="stylesheet" href="/scalaz-zio/css/override.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalaz-zio/" class="brand"><div class="brand-wrapper"><span></span></div></a></li> <li><a href="/scalaz-zio/overview/" class="">Overview</a> <ul class="sub_section"> <li><a href="/scalaz-zio/overview/creating_effects.html" class="">Creating Effects</a></li> <li><a href="/scalaz-zio/overview/basic_operations.html" class="">Basic Operations</a></li> <li><a href="/scalaz-zio/overview/handling_errors.html" class="">Handling Errors</a></li> <li><a href="/scalaz-zio/overview/handling_resources.html" class="">Handling Resources</a></li> <li><a href="/scalaz-zio/overview/basic_concurrency.html" class=" active ">Basic Concurrency</a></li> <li><a href="/scalaz-zio/overview/testing_effects.html" class="">Testing Effects</a></li> <li><a href="/scalaz-zio/overview/running_effects.html" class="">Running Effects</a></li> <li><a href="/scalaz-zio/overview/background.html" class="">Background</a></li></ul></li>    </ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/scalaz/scalaz-zio"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/scalaz/scalaz-zio"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li></ul></div></div></div></div><div id="content" data-github-owner="scalaz" data-github-repo="scalaz-zio"><div class="content-wrapper"><section><h1 id="basic-concurrency">Basic Concurrency</h1>

<p>ZIO has low-level support for concurrency using <em>fibers</em>. While fibers are very powerful, they are low-level. To improve productivity, ZIO provides high-level operations built on fibers.</p>

<p>If you are able to do so, you should always use higher-level operations, rather than working with fibers directly. For the sake of completeness, this section introduces both fibers and some of the higher-level operations built on them.</p>

<h1 id="fibers">Fibers</h1>

<p>ZIO’s concurrency is built on <em>fibers</em>, which are lightweight “green threads” implemented by the ZIO runtime.</p>

<p>Unlike operating system threads, fibers consume almost no memory, have growable and shrinkable stacks, don’t waste resources blocking, and will be garbage collected automatically if they are inactive and unreachable.</p>

<p>Fibers are scheduled by the ZIO runtime and will cooperatively yield to each other, which enables multitasking even when operating in a single-threaded environment (like Javascript, or even the JVM when configured with one thread).</p>

<p>All effects in ZIO are executed by <em>some</em> fiber. If you did not create the fiber, then the fiber was created by some operation you are using (if the operation is concurrent or parallel), or by the runtime system.</p>

<p>Even if you only write “single-threaded” code, with no parallel or concurrent operations, then there will be at least one fiber: the “main” fiber that executes your effect.</p>

<h2 id="the-fiber-data-type">The Fiber Data Type</h2>

<p>The <code class="highlighter-rouge">Fiber[E, A]</code> data type in ZIO has two type parameters:</p>

<ul>
  <li><strong><code class="highlighter-rouge">E</code> Failure Type</strong>. This is the type of value the effect being executed by the fiber may fail with.</li>
  <li><strong><code class="highlighter-rouge">A</code> Success Type</strong>. This is the type of value the effect being executed by the fiber may succeed with.</li>
</ul>

<p>Fibers do not have an <code class="highlighter-rouge">R</code> type parameter, because they model effects that are already being executed, and which therefore have already had their required environment provided to them.</p>

<h2 id="forking-effects">Forking Effects</h2>

<p>The most primitive way of creating a fiber is to take an effect and <em>fork</em> it. Conceptually, <em>forking</em> an effect immediately begins executing the effect on a new fiber, giving you the new fiber.</p>

<p>The following code creates a single fiber, which executes <code class="highlighter-rouge">fib(100)</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">UIO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">UIO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="n">zipWith</span><span class="o">(</span><span class="n">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">))(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">UIO</span><span class="o">[</span><span class="kt">Fiber</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">Long</span><span class="o">]]</span> <span class="k">=</span> 
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">fiber</span> <span class="k">&lt;-</span> <span class="n">fib</span><span class="o">(</span><span class="mi">100</span><span class="o">).</span><span class="n">fork</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">fiber</span>
</code></pre></div></div>

<h2 id="joining-effects">Joining Effects</h2>

<p>One of the methods on <code class="highlighter-rouge">Fiber</code> is <code class="highlighter-rouge">join</code>, which allows another fiber to obtain the result of the fiber being joined. This is similar to awaiting the final result of the fiber, whether that is failure or success.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">fiber</span>   <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="s">"Hi!"</span><span class="o">).</span><span class="n">fork</span>
  <span class="n">message</span> <span class="k">&lt;-</span> <span class="n">fiber</span><span class="o">.</span><span class="n">join</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">message</span>
</code></pre></div></div>

<h2 id="awaiting-fibers">Awaiting Fibers</h2>

<p>Another method on <code class="highlighter-rouge">Fiber</code> is <code class="highlighter-rouge">await</code>, which allows for inspecting the result of a completed <code class="highlighter-rouge">Fiber</code>. This provides access to full details on how the fiber completed, represented by the <code class="highlighter-rouge">Exit</code> data type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">fiber</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="s">"Hi!"</span><span class="o">).</span><span class="n">fork</span>
  <span class="n">exit</span>  <span class="k">&lt;-</span> <span class="n">fiber</span><span class="o">.</span><span class="n">await</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">exit</span>
</code></pre></div></div>

<h2 id="interrupting-fibers">Interrupting Fibers</h2>

<p>A fiber whose result is no longer needed may be <em>interrupted</em>, which immediately terminates the fiber, safely releasing all resources and running all finalizers.</p>

<p>Like <code class="highlighter-rouge">await</code>, <code class="highlighter-rouge">Fiber#interrupt</code> returns an <code class="highlighter-rouge">Exit</code> describing how the fiber terminated.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">fiber</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="s">"Hi!"</span><span class="o">).</span><span class="n">forever</span><span class="o">.</span><span class="n">fork</span>
  <span class="n">exit</span>  <span class="k">&lt;-</span> <span class="n">fiber</span><span class="o">.</span><span class="n">interrupt</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">exit</span>
</code></pre></div></div>

<p>By design, <code class="highlighter-rouge">interrupt</code> does not resume until the fiber has terminated. If this behavior is not desired, you can <code class="highlighter-rouge">fork</code> the interruption itself:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">fiber</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="s">"Hi!"</span><span class="o">).</span><span class="n">forever</span><span class="o">.</span><span class="n">fork</span>
  <span class="k">_</span>     <span class="k">&lt;-</span> <span class="n">fiber</span><span class="o">.</span><span class="n">interrupt</span><span class="o">.</span><span class="n">fork</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<h2 id="composing-fibers">Composing Fibers</h2>

<p>Fibers may be composed in several ways.</p>

<p>One way fibers may be composed is with <code class="highlighter-rouge">Fiber#zip</code> or <code class="highlighter-rouge">Fiber#zipWith</code>. These methods combine two fibers into a single fiber that produces the results of both. If either fiber fails, then the composed fiber will fail.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">fiber1</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="s">"Hi!"</span><span class="o">).</span><span class="n">fork</span>
  <span class="n">fiber2</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="s">"Bye!"</span><span class="o">).</span><span class="n">fork</span>
  <span class="n">fiber</span>   <span class="k">=</span> <span class="n">fiber1</span> <span class="n">zip</span> <span class="n">fiber2</span>
  <span class="n">tuple</span>  <span class="k">&lt;-</span> <span class="n">fiber</span><span class="o">.</span><span class="n">join</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">tuple</span>
</code></pre></div></div>

<p>The second way fibers can be composed is with <code class="highlighter-rouge">orElse</code>. If the first fiber succeeds, the composed fiber will succeed with that result; otherwise, the composed fiber will complete with the exit of the second fiber.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">fiber1</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">fail</span><span class="o">(</span><span class="s">"Uh oh!"</span><span class="o">).</span><span class="n">fork</span>
  <span class="n">fiber2</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="s">"Hurray!"</span><span class="o">).</span><span class="n">fork</span>
  <span class="n">fiber</span>   <span class="k">=</span> <span class="n">fiber1</span> <span class="n">orElse</span> <span class="n">fiber2</span>
  <span class="n">tuple</span>  <span class="k">&lt;-</span> <span class="n">fiber</span><span class="o">.</span><span class="n">join</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">tuple</span>
</code></pre></div></div>

<h1 id="parallelism">Parallelism</h1>

<p>ZIO provides many operations for performing effects in parallel. These methods are all named with a <code class="highlighter-rouge">Par</code> suffix that helps you more easily identify opportunities to parallelize your code.</p>

<p>For example, the ordinary <code class="highlighter-rouge">ZIO#zip</code> method zips two effects together, sequentially. But there is also a <code class="highlighter-rouge">ZIO#zipPar</code> method, which zips two effects together in parallel.</p>

<p>The following table summarizes some of the sequential operations and their corresponding parallel versions:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right"><strong>Description</strong></th>
      <th style="text-align: center"><strong>Sequential</strong></th>
      <th style="text-align: center"><strong>Parallel</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">Zips two effects into one</td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO#zip</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO#zipPar</code></td>
    </tr>
    <tr>
      <td style="text-align: right">Zips two effects into one</td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO#zipWith</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO#zipWithPar</code></td>
    </tr>
    <tr>
      <td style="text-align: right">Collects from many effects</td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO.collectAll</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO.collectAllPar</code></td>
    </tr>
    <tr>
      <td style="text-align: right">Effectfully loop over values</td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO.foreach</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO.foreachPar</code></td>
    </tr>
    <tr>
      <td style="text-align: right">Reduces many values</td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO.reduceAll</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO.reduceAllPar</code></td>
    </tr>
    <tr>
      <td style="text-align: right">Merges many values</td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO.mergeAll</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">ZIO.mergeAllPar</code></td>
    </tr>
  </tbody>
</table>

<p>For all the parallel operations, if one effect fails, then others will be interrupted, to minimize unnecessary computation. If this behavior is not desired, the potentially failing effects can be converted into infallible effects using the <code class="highlighter-rouge">ZIO#either</code> or <code class="highlighter-rouge">ZIO#option</code> methods.</p>

<h1 id="racing">Racing</h1>

<p>ZIO allows you to race multiple effects in parallel, returning the first successful result:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">winner</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">)</span> <span class="n">race</span> <span class="nc">IO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="s">"Goodbye"</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">winner</span>
</code></pre></div></div>

<p>If you want the first success or failure, rather than the first success, then you can use <code class="highlighter-rouge">left.either race right.either</code>, for any effects <code class="highlighter-rouge">left</code> and <code class="highlighter-rouge">right</code>.</p>

<h1 id="timeout">Timeout</h1>

<p>ZIO lets you timeout any effect using the <code class="highlighter-rouge">ZIO#timeout</code> method, which succeeds with an <code class="highlighter-rouge">Option</code>, where a value of <code class="highlighter-rouge">None</code> indicates the effect timed out before producing the result.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.zio.duration._</span>

<span class="nc">IO</span><span class="o">.</span><span class="n">succeed</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">).</span><span class="n">timeout</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>
</code></pre></div></div>

<p>If an effect is timed out, then instead of continuing to execute in the background, it will be interrupted so no resources will be wasted.</p>

<h1 id="next-steps">Next Steps</h1>

<p>If you are comfortable with basic concurrency, then the next step is to learn about <a href="testing_effects.html">testing effects</a>.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalaz-zio/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'scalaz/scalaz-zio'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scalaz-zio/js/main.js"></script></body></html>